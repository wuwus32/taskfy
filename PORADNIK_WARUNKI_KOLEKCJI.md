# Poradnik: Dodawanie warunk√≥w kolekcji do Shopify Discount Functions

## Wprowadzenie

Ten poradnik pokazuje, jak zaimplementowaƒá warunki dotyczƒÖce kolekcji produkt√≥w w Shopify Function (discount function), kt√≥ra przyznaje zni≈ºkƒô tylko wtedy, gdy spe≈Çnione sƒÖ okre≈õlone warunki dotyczƒÖce produkt√≥w z danej kolekcji w koszyku.

## Dostƒôpne warunki kolekcji

1. **co najmniej jeden produkt z kolekcji** - koszyk ma co najmniej jeden produkt z danej kolekcji
2. **≈ºaden produkt z kolekcji** - koszyk NIE posiada produktu z danej kolekcji  
3. **wszystkie produkty z kolekcji** - koszyk posiada WSZYSTKIE produkty z danej kolekcji
4. **tylko produkty z kolekcji** - koszyk posiada produkty JEDYNIE z danej kolekcji

## Krok 1: Konfiguracja zapytania GraphQL

### 1.1 Aktualizacja pliku GraphQL

W pliku `src/cart_lines_discounts_generate_run.graphql` dodaj obs≈Çugƒô kolekcji:

```graphql
query CartLinesDiscountsGenerateRun($collectionIds: [ID!]) {
  cart {
    lines {
      id
      quantity
      cost {
        subtotalAmount {
          amount
        }
      }
      merchandise {
        ... on ProductVariant {
          id
          weight
          product {
            id
            inAnyCollection(ids: $collectionIds)
            inCollections(ids: $collectionIds) {
              id
              title
            }
          }
        }
      }
    }
    # ... reszta zapytania
  }
  # ... reszta zapytania
}
```

**Kluczowe pola:**
- `inAnyCollection(ids: $collectionIds)` - zwraca `true` je≈õli produkt nale≈ºy do kt√≥rejkolwiek z przekazanych kolekcji
- `inCollections(ids: $collectionIds)` - zwraca szczeg√≥≈Çowe informacje o kolekcjach do kt√≥rych nale≈ºy produkt

### 1.2 Konfiguracja zmiennych w shopify.extension.toml

Dodaj sekcjƒô `[extensions.input.variables]` do pliku `shopify.extension.toml`:

```toml
api_version = "2025-04"

[[extensions]]
name = "t:name"
handle = "taskfy-advanced-discounts"
type = "function"
discount_classes = ["ORDER", "PRODUCT", "SHIPPING"]

description = "t:description"

  [[extensions.targeting]]
  target = "cart.lines.discounts.generate.run"
  input_query = "src/cart_lines_discounts_generate_run.graphql"
  export = "cart-lines-discounts-generate-run"

  [extensions.input.variables]
  namespace = "$app:discount"
  key = "input-variables"

  [extensions.build]
  command = ""
  path = "dist/function.wasm"
```

## Krok 2: Implementacja logiki w JavaScript

### 2.1 Dodanie warunk√≥w kolekcji do funkcji

W pliku `src/cart_lines_discounts_generate_run.js` dodaj obs≈Çugƒô warunk√≥w kolekcji w funkcji `checkIndividualConditions`:

```javascript
case 'cart_contains': {
  // Sprawd≈∫ czy operator dotyczy kolekcji
  const isCollectionOperator = [
    'only_these_collections',
    'at_least_one_collection',
    'no_products_from_collections'
  ].includes(condition.operator);
  
  if (isCollectionOperator) {
    console.log('üîç [CART_CONTAINS DEBUG] Processing collection operator');
    
    // Parse required collection IDs
    const requiredCollectionIds = condition.value.split(',').map(id => id.trim()).filter(Boolean);
    
    // Get all cart products that belong to the specified collections
    const cartProductsFromCollections = cart.lines.filter(line => {
      const product = line.merchandise?.product;
      if (!product) return false;
      return product.inAnyCollection === true;
    });
    
    let conditionMet = false;
    
    switch (condition.operator) {
      case 'only_these_collections': {
        // Wszystkie produkty w koszyku muszƒÖ byƒá z okre≈õlonych kolekcji
        conditionMet = cart.lines.length > 0 && cart.lines.every(line => {
          const product = line.merchandise?.product;
          if (!product) return false;
          return product.inAnyCollection === true;
        });
        break;
      }
      
      case 'at_least_one_collection': {
        // Co najmniej jeden produkt musi byƒá z okre≈õlonych kolekcji
        conditionMet = cart.lines.some(line => {
          const product = line.merchandise?.product;
          if (!product) return false;
          return product.inAnyCollection === true;
        });
        break;
      }
      

      
      case 'no_products_from_collections': {
        // ≈ªaden produkt w koszyku nie powinien byƒá z okre≈õlonych kolekcji
        conditionMet = !cart.lines.some(line => {
          const product = line.merchandise?.product;
          if (!product) return false;
          return product.inAnyCollection === true;
        });
        break;
      }
    }
    
    if (!conditionMet) {
      console.log(`‚ùå Collection condition failed: ${condition.operator} with value ${condition.value}`);
      return false;
    }
    
    console.log(`‚úÖ Collection condition passed: ${condition.operator}`);
  }
  
  // ... obs≈Çuga innych operator√≥w cart_contains
  break;
}
```

## Krok 3: Konfiguracja aplikacji g≈Ç√≥wnej

### 3.1 Dodanie metafield input variables przy tworzeniu zni≈ºki

W g≈Ç√≥wnej aplikacji (`app._index.jsx`), w funkcji `handleCreateDiscount`, dodaj tworzenie metafield z `collectionIds`:

```javascript
// Pobierz collectionIds z warunk√≥w kolekcji dla zapytania GraphQL
const collectionIds = [];
if (discountData.conditions) {
  discountData.conditions.forEach(condition => {
    if (condition.type === 'cart_contains' && condition.value) {
      const isCollectionOperator = [
        'only_these_collections',
        'at_least_one_collection',
        'no_products_from_collections'
      ].includes(condition.operator);
      
      if (isCollectionOperator) {
        const conditionCollectionIds = condition.value.split(',').map(id => id.trim()).filter(Boolean);
        collectionIds.push(...conditionCollectionIds);
      }
    }
  });
}

// Metafield dla input variables zapytania GraphQL (dla Shopify Functions)
const inputVariablesValue = {
  collectionIds: Array.from(new Set(collectionIds)) // usu≈Ñ duplikaty
};

// Przy tworzeniu metafields, dodaj input variables:
const metafieldResult = await callShopify(metafieldMutation, {
  metafields: [
    {
      ownerId: shopifyDiscountId,
      namespace: "$app:taskify-discounts",
      key: "function-configuration",
      type: "json",
      value: JSON.stringify(metafieldValue)
    },
    {
      ownerId: shopifyDiscountId,
      namespace: "$app:discount",
      key: "input-variables",
      type: "json",
      value: JSON.stringify(inputVariablesValue)
    }
  ]
});
```

### 3.2 Funkcja aktualizacji metafield dla istniejƒÖcych zni≈ºek

```javascript
// FUNKCJA POMOCNICZA DO AKTUALIZACJI METAFIELD INPUT VARIABLES NA ISTNIEJƒÑCYCH ZNI≈ªKACH
const updateDiscountInputVariables = async (discount) => {
  if (!discount.shopifyDiscountId) {
    console.log("üîç Skipping metafield update - no Shopify discount ID for:", discount.name);
    return;
  }

  try {
    // Pobierz collectionIds z warunk√≥w kolekcji
    const collectionIds = [];
    if (discount.conditions) {
      discount.conditions.forEach(condition => {
        if (condition.type === 'cart_contains' && condition.value) {
          const isCollectionOperator = [
            'only_these_collections',
            'at_least_one_collection',
            'no_products_from_collections'
          ].includes(condition.operator);
          
          if (isCollectionOperator) {
            const conditionCollectionIds = condition.value.split(',').map(id => id.trim()).filter(Boolean);
            collectionIds.push(...conditionCollectionIds);
          }
        }
      });
    }

    const inputVariablesValue = {
      collectionIds: Array.from(new Set(collectionIds)) // usu≈Ñ duplikaty
    };

    const metafieldMutation = `
      mutation metafieldsSet($metafields: [MetafieldsSetInput!]!) {
        metafieldsSet(metafields: $metafields) {
          metafields {
            id
            namespace
            key
          }
          userErrors {
            field
            message
            code
          }
        }
      }
    `;
    
    const metafieldResult = await callShopify(metafieldMutation, {
      metafields: [
        {
          ownerId: discount.shopifyDiscountId,
          namespace: "$app:discount",
          key: "input-variables",
          type: "json",
          value: JSON.stringify(inputVariablesValue)
        }
      ]
    });
    
    if (metafieldResult.metafieldsSet?.userErrors?.length > 0) {
      console.warn("‚ö†Ô∏è B≈ÇƒÖd aktualizacji input variables metafield:", metafieldResult.metafieldsSet.userErrors);
    } else {
      console.log(`‚úÖ Zaktualizowano input variables metafield dla zni≈ºki: ${discount.name}`);
    }
  } catch (error) {
    console.warn(`‚ö†Ô∏è Nie uda≈Ço siƒô zaktualizowaƒá input variables dla zni≈ºki ${discount.name}:`, error);
  }
};
```

## Krok 4: Przyk≈Çady u≈ºycia

### 4.1 Warunek: "Co najmniej jeden produkt z kolekcji"

```javascript
const condition = {
  type: 'cart_contains',
  operator: 'at_least_one_collection',
  value: 'gid://shopify/Collection/123456789' // ID kolekcji
};
```

### 4.2 Warunek: "Tylko produkty z kolekcji"

```javascript
const condition = {
  type: 'cart_contains',
  operator: 'only_these_collections',
  value: 'gid://shopify/Collection/123456789,gid://shopify/Collection/987654321' // Wiele kolekcji oddzielonych przecinkami
};
```

### 4.3 Warunek: "≈ªaden produkt z kolekcji"

```javascript
const condition = {
  type: 'cart_contains',
  operator: 'no_products_from_collections',
  value: 'gid://shopify/Collection/123456789'
};
```



## Krok 5: Testowanie

### 5.1 Przyk≈Çadowy input JSON dla test√≥w

```json
{
  "cart": {
    "lines": [
      {
        "id": "gid://shopify/CartLine/1",
        "merchandise": {
          "__typename": "ProductVariant",
          "product": {
            "id": "gid://shopify/Product/111",
            "inAnyCollection": true,
            "inCollections": [
              {
                "id": "gid://shopify/Collection/123456789",
                "title": "Kolekcja testowa"
              }
            ]
          }
        }
      }
    ]
  },
  "discount": {
    "discountClasses": ["PRODUCT"],
    "metafield": {
      "value": "{\"collectionIds\": [\"gid://shopify/Collection/123456789\"]}"
    }
  }
}
```

### 5.2 Weryfikacja dzia≈Çania

1. **Logi w funkcji** - sprawd≈∫ logi w Shopify Admin > Settings > Functions
2. **Test w koszyku** - dodaj produkty do koszyka i sprawd≈∫ czy zni≈ºka siƒô aktywuje
3. **Debugowanie** - u≈ºyj `console.log` do ≈õledzenia warto≈õci `inAnyCollection` i `inCollections`

## Krok 6: Wdro≈ºenie

### 6.1 Deploy funkcji

```bash
shopify app deploy
```

### 6.2 Weryfikacja w Shopify Admin

1. Przejd≈∫ do **Shopify Admin > Settings > Functions**
2. Sprawd≈∫ czy funkcja jest wdro≈ºona
3. Przetestuj z rzeczywistymi produktami i kolekcjami

## Wa≈ºne uwagi

1. **Limity**: Shopify ogranicza zmienne zapytania GraphQL do maksymalnie 100 element√≥w w li≈õcie
2. **Performance**: Im wiƒôcej collectionIds, tym wolniejsze zapytanie - u≈ºywaj minimalnej liczby potrzebnych kolekcji
3. **Fallback**: Zawsze implementuj fallback dla przypadk√≥w, gdy dane o kolekcjach nie sƒÖ dostƒôpne
4. **Debugowanie**: U≈ºywaj szczeg√≥≈Çowego logowania do debugowania warunk√≥w kolekcji

## Najczƒôstsze problemy

1. **B≈ÇƒÖd "inAnyCollection not found"** - sprawd≈∫ czy zapytanie GraphQL ma poprawnie zdefiniowanƒÖ zmiennƒÖ `$collectionIds`
2. **Input variables nie dzia≈ÇajƒÖ** - sprawd≈∫ namespace i key w `shopify.extension.toml`
3. **Zni≈ºka nie aktywuje siƒô** - sprawd≈∫ logi funkcji w Shopify Admin
4. **Metafield nie zapisuje siƒô** - sprawd≈∫ czy ID zni≈ºki jest poprawne

Powodzenia z implementacjƒÖ warunk√≥w kolekcji w Shopify Functions! üöÄ 